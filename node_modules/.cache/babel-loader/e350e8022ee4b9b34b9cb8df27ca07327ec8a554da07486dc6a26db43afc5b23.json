{"ast":null,"code":"/* globals chrome: false */\n/* globals __dirname: false */\n/* globals require: false */\n/* globals Buffer: false */\n/* globals module: false */\n/**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style\n * dictionaries.\n */\nvar Typo;\n(function () {\n  \"use strict\";\n\n  /**\n   * Typo constructor.\n   *\n   * @param {string} [dictionary] The locale code of the dictionary being used. e.g.,\n   *                              \"en_US\". This is only used to auto-load dictionaries.\n   * @param {string} [affData]    The data from the dictionary's .aff file. If omitted\n   *                              and Typo.js is being used in a Chrome extension, the .aff\n   *                              file will be loaded automatically from\n   *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff\n   *                              In other environments, it will be loaded from\n   *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff\n   * @param {string} [wordsData]  The data from the dictionary's .dic file. If omitted\n   *                              and Typo.js is being used in a Chrome extension, the .dic\n   *                              file will be loaded automatically from\n   *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic\n   *                              In other environments, it will be loaded from\n   *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic\n   * @param {Object} [settings]   Constructor settings. Available properties are:\n   *                              {string} [dictionaryPath]: path to load dictionary from in non-chrome\n   *                              environment.\n   *                              {Object} [flags]: flag information.\n   *                              {boolean} [asyncLoad]: If true, affData and wordsData will be loaded\n   *                              asynchronously.\n   *                              {Function} [loadedCallback]: Called when both affData and wordsData\n   *                              have been loaded. Only used if asyncLoad is set to true. The parameter\n   *                              is the instantiated Typo object.\n   *\n   * @returns {Typo} A Typo object.\n   */\n  Typo = function (dictionary, affData, wordsData, settings) {\n    settings = settings || {};\n    this.dictionary = null;\n    this.rules = {};\n    this.dictionaryTable = {};\n    this.compoundRules = [];\n    this.compoundRuleCodes = {};\n    this.replacementTable = [];\n    this.flags = settings.flags || {};\n    this.memoized = {};\n    this.loaded = false;\n    var self = this;\n    var path;\n    // Loop-control variables.\n    var i, j, _len, _jlen;\n    if (dictionary) {\n      self.dictionary = dictionary;\n      // If the data is preloaded, just setup the Typo object.\n      if (affData && wordsData) {\n        setup();\n      }\n      // Loading data for Chrome extentions.\n      else if (typeof window !== 'undefined' && (window.chrome || window.browser)) {\n        var runtime = window.chrome && window.chrome.runtime ? window.chrome.runtime : browser.runtime;\n        if (settings.dictionaryPath) {\n          path = settings.dictionaryPath;\n        } else {\n          path = \"typo/dictionaries\";\n        }\n        if (!affData) readDataFile(runtime.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\"), setAffData);\n        if (!wordsData) readDataFile(runtime.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\"), setWordsData);\n      }\n      // Loading data for Node.js or other environments.\n      else {\n        if (settings.dictionaryPath) {\n          path = settings.dictionaryPath;\n        } else if (typeof __dirname !== 'undefined') {\n          path = __dirname + '/dictionaries';\n        } else {\n          path = './dictionaries';\n        }\n        if (!affData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\", setAffData);\n        if (!wordsData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\", setWordsData);\n      }\n    }\n    function readDataFile(url, setFunc) {\n      var response = self._readFile(url, null, settings === null || settings === void 0 ? void 0 : settings.asyncLoad);\n      if (settings === null || settings === void 0 ? void 0 : settings.asyncLoad) {\n        response.then(function (data) {\n          setFunc(data);\n        });\n      } else {\n        setFunc(response);\n      }\n    }\n    function setAffData(data) {\n      affData = data;\n      if (wordsData) {\n        setup();\n      }\n    }\n    function setWordsData(data) {\n      wordsData = data;\n      if (affData) {\n        setup();\n      }\n    }\n    function setup() {\n      self.rules = self._parseAFF(affData);\n      // Save the rule codes that are used in compound rules.\n      self.compoundRuleCodes = {};\n      for (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n        var rule = self.compoundRules[i];\n        for (j = 0, _jlen = rule.length; j < _jlen; j++) {\n          self.compoundRuleCodes[rule[j]] = [];\n        }\n      }\n      // If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n      // will do the work of saving the list of words that are compound-only.\n      if (\"ONLYINCOMPOUND\" in self.flags) {\n        self.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];\n      }\n      self.dictionaryTable = self._parseDIC(wordsData);\n      // Get rid of any codes from the compound rule codes that are never used\n      // (or that were special regex characters).  Not especially necessary...\n      for (i in self.compoundRuleCodes) {\n        if (self.compoundRuleCodes[i].length === 0) {\n          delete self.compoundRuleCodes[i];\n        }\n      }\n      // Build the full regular expressions for each compound rule.\n      // I have a feeling (but no confirmation yet) that this method of\n      // testing for compound words is probably slow.\n      for (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n        var ruleText = self.compoundRules[i];\n        var expressionText = \"\";\n        for (j = 0, _jlen = ruleText.length; j < _jlen; j++) {\n          var character = ruleText[j];\n          if (character in self.compoundRuleCodes) {\n            expressionText += \"(\" + self.compoundRuleCodes[character].join(\"|\") + \")\";\n          } else {\n            expressionText += character;\n          }\n        }\n        self.compoundRules[i] = new RegExp('^' + expressionText + '$', \"i\");\n      }\n      self.loaded = true;\n      if ((settings === null || settings === void 0 ? void 0 : settings.asyncLoad) && (settings === null || settings === void 0 ? void 0 : settings.loadedCallback)) {\n        settings.loadedCallback(self);\n      }\n    }\n    return this;\n  };\n  Typo.prototype = {\n    /**\n     * Loads a Typo instance from a hash of all of the Typo properties.\n     *\n     * @param {object} obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n     */\n    load: function (obj) {\n      for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          this[i] = obj[i];\n        }\n      }\n      return this;\n    },\n    /**\n     * Read the contents of a file.\n     *\n     * @param {string} path The path (relative) to the file.\n     * @param {string} [charset=\"ISO8859-1\"] The expected charset of the file\n     * @param {boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n     *        files are read synchronously.\n     * @returns {string} The file data if async is false, otherwise a promise object. If running node.js, the data is\n     *          always returned.\n     */\n    _readFile: function (path, charset, async) {\n      var _a;\n      charset = charset || \"utf8\";\n      if (typeof XMLHttpRequest !== 'undefined') {\n        var req_1 = new XMLHttpRequest();\n        req_1.open(\"GET\", path, !!async);\n        (_a = req_1.overrideMimeType) === null || _a === void 0 ? void 0 : _a.call(req_1, \"text/plain; charset=\" + charset);\n        if (!!async) {\n          var promise = new Promise(function (resolve, reject) {\n            req_1.onload = function () {\n              if (req_1.status === 200) {\n                resolve(req_1.responseText);\n              } else {\n                reject(req_1.statusText);\n              }\n            };\n            req_1.onerror = function () {\n              reject(req_1.statusText);\n            };\n          });\n          req_1.send(null);\n          return promise;\n        } else {\n          req_1.send(null);\n          return req_1.responseText;\n        }\n      } else if (typeof require !== 'undefined') {\n        // Node.js\n        var fs = require(\"fs\");\n        try {\n          if (fs.existsSync(path)) {\n            return fs.readFileSync(path, charset);\n          } else {\n            console.log(\"Path \" + path + \" does not exist.\");\n          }\n        } catch (e) {\n          console.log(e);\n        }\n        return '';\n      }\n      return '';\n    },\n    /**\n     * Parse the rules out from a .aff file.\n     *\n     * @param {string} data The contents of the affix file.\n     * @returns object The rules from the file.\n     */\n    _parseAFF: function (data) {\n      var rules = {};\n      var line, subline, numEntries, lineParts;\n      var i, j, _len, _jlen;\n      var lines = data.split(/\\r?\\n/);\n      for (i = 0, _len = lines.length; i < _len; i++) {\n        // Remove comment lines\n        line = this._removeAffixComments(lines[i]);\n        line = line.trim();\n        if (!line) {\n          continue;\n        }\n        var definitionParts = line.split(/\\s+/);\n        var ruleType = definitionParts[0];\n        if (ruleType === \"PFX\" || ruleType === \"SFX\") {\n          var ruleCode = definitionParts[1];\n          var combineable = definitionParts[2];\n          numEntries = parseInt(definitionParts[3], 10);\n          var entries = [];\n          for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n            subline = lines[j];\n            lineParts = subline.split(/\\s+/);\n            var charactersToRemove = lineParts[2];\n            var additionParts = lineParts[3].split(\"/\");\n            var charactersToAdd = additionParts[0];\n            if (charactersToAdd === \"0\") charactersToAdd = \"\";\n            var continuationClasses = this.parseRuleCodes(additionParts[1]);\n            var regexToMatch = lineParts[4];\n            var entry = {\n              add: charactersToAdd\n            };\n            if (continuationClasses.length > 0) entry.continuationClasses = continuationClasses;\n            if (regexToMatch !== \".\") {\n              if (ruleType === \"SFX\") {\n                entry.match = new RegExp(regexToMatch + \"$\");\n              } else {\n                entry.match = new RegExp(\"^\" + regexToMatch);\n              }\n            }\n            if (charactersToRemove != \"0\") {\n              if (ruleType === \"SFX\") {\n                entry.remove = new RegExp(charactersToRemove + \"$\");\n              } else {\n                entry.remove = charactersToRemove;\n              }\n            }\n            entries.push(entry);\n          }\n          rules[ruleCode] = {\n            \"type\": ruleType,\n            \"combineable\": combineable === \"Y\",\n            \"entries\": entries\n          };\n          i += numEntries;\n        } else if (ruleType === \"COMPOUNDRULE\") {\n          numEntries = parseInt(definitionParts[1], 10);\n          for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n            line = lines[j];\n            lineParts = line.split(/\\s+/);\n            this.compoundRules.push(lineParts[1]);\n          }\n          i += numEntries;\n        } else if (ruleType === \"REP\") {\n          lineParts = line.split(/\\s+/);\n          if (lineParts.length === 3) {\n            this.replacementTable.push([lineParts[1], lineParts[2]]);\n          }\n        } else {\n          // ONLYINCOMPOUND\n          // COMPOUNDMIN\n          // FLAG\n          // KEEPCASE\n          // NEEDAFFIX\n          this.flags[ruleType] = definitionParts[1];\n        }\n      }\n      return rules;\n    },\n    /**\n     * Removes comments.\n     *\n     * @param {string} data A line from an affix file.\n     * @return {string} The cleaned-up line.\n     */\n    _removeAffixComments: function (line) {\n      // This used to remove any string starting with '#' up to the end of the line,\n      // but some COMPOUNDRULE definitions include '#' as part of the rule.\n      // So, only remove lines that begin with a comment, optionally preceded by whitespace.\n      if (line.match(/^\\s*#/)) {\n        return '';\n      }\n      return line;\n    },\n    /**\n     * Parses the words out from the .dic file.\n     *\n     * @param {string} data The data from the dictionary file.\n     * @returns HashMap The lookup table containing all of the words and\n     *                 word forms from the dictionary.\n     */\n    _parseDIC: function (data) {\n      data = this._removeDicComments(data);\n      var lines = data.split(/\\r?\\n/);\n      var dictionaryTable = {};\n      function addWord(word, rules) {\n        // Some dictionaries will list the same word multiple times with different rule sets.\n        if (!dictionaryTable.hasOwnProperty(word)) {\n          dictionaryTable[word] = null;\n        }\n        if (rules.length > 0) {\n          if (dictionaryTable[word] === null) {\n            dictionaryTable[word] = [];\n          }\n          dictionaryTable[word].push(rules);\n        }\n      }\n      // The first line is the number of words in the dictionary.\n      for (var i = 1, _len = lines.length; i < _len; i++) {\n        var line = lines[i];\n        if (!line) {\n          // Ignore empty lines.\n          continue;\n        }\n        var parts = line.split(\"/\", 2);\n        var word = parts[0];\n        // Now for each affix rule, generate that form of the word.\n        if (parts.length > 1) {\n          var ruleCodesArray = this.parseRuleCodes(parts[1]);\n          // Save the ruleCodes for compound word situations.\n          if (!(\"NEEDAFFIX\" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) === -1) {\n            addWord(word, ruleCodesArray);\n          }\n          for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {\n            var code = ruleCodesArray[j];\n            var rule = this.rules[code];\n            if (rule) {\n              var newWords = this._applyRule(word, rule);\n              for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {\n                var newWord = newWords[ii];\n                addWord(newWord, []);\n                if (rule.combineable) {\n                  for (var k = j + 1; k < _jlen; k++) {\n                    var combineCode = ruleCodesArray[k];\n                    var combineRule = this.rules[combineCode];\n                    if (combineRule) {\n                      if (combineRule.combineable && rule.type != combineRule.type) {\n                        var otherNewWords = this._applyRule(newWord, combineRule);\n                        for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {\n                          var otherNewWord = otherNewWords[iii];\n                          addWord(otherNewWord, []);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            if (code in this.compoundRuleCodes) {\n              this.compoundRuleCodes[code].push(word);\n            }\n          }\n        } else {\n          addWord(word.trim(), []);\n        }\n      }\n      return dictionaryTable;\n    },\n    /**\n     * Removes comment lines and then cleans up blank lines and trailing whitespace.\n     *\n     * @param {string} data The data from a .dic file.\n     * @return {string} The cleaned-up data.\n     */\n    _removeDicComments: function (data) {\n      // I can't find any official documentation on it, but at least the de_DE\n      // dictionary uses tab-indented lines as comments.\n      // Remove comments\n      data = data.replace(/^\\t.*$/mg, \"\");\n      return data;\n    },\n    parseRuleCodes: function (textCodes) {\n      if (!textCodes) {\n        return [];\n      } else if (!(\"FLAG\" in this.flags)) {\n        // The flag symbols are single characters\n        return textCodes.split(\"\");\n      } else if (this.flags.FLAG === \"long\") {\n        // The flag symbols are two characters long.\n        var flags = [];\n        for (var i = 0, _len = textCodes.length; i < _len; i += 2) {\n          flags.push(textCodes.substr(i, 2));\n        }\n        return flags;\n      } else if (this.flags.FLAG === \"num\") {\n        // The flag symbols are a CSV list of numbers.\n        return textCodes.split(\",\");\n      } else if (this.flags.FLAG === \"UTF-8\") {\n        // The flags are single UTF-8 characters.\n        // @see https://github.com/cfinke/Typo.js/issues/57\n        return Array.from(textCodes);\n      } else {\n        // It's possible that this fallback case will not work for all FLAG values,\n        // but I think it's more likely to work than not returning anything at all.\n        return textCodes.split(\"\");\n      }\n    },\n    /**\n     * Applies an affix rule to a word.\n     *\n     * @param {string} word The base word.\n     * @param {Object} rule The affix rule.\n     * @returns {string[]} The new words generated by the rule.\n     */\n    _applyRule: function (word, rule) {\n      var entries = rule.entries;\n      var newWords = [];\n      for (var i = 0, _len = entries.length; i < _len; i++) {\n        var entry = entries[i];\n        if (!entry.match || word.match(entry.match)) {\n          var newWord = word;\n          if (entry.remove) {\n            newWord = newWord.replace(entry.remove, \"\");\n          }\n          if (rule.type === \"SFX\") {\n            newWord = newWord + entry.add;\n          } else {\n            newWord = entry.add + newWord;\n          }\n          newWords.push(newWord);\n          if (\"continuationClasses\" in entry) {\n            for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {\n              var continuationRule = this.rules[entry.continuationClasses[j]];\n              if (continuationRule) {\n                newWords = newWords.concat(this._applyRule(newWord, continuationRule));\n              }\n              /*\n              else {\n                  // This shouldn't happen, but it does, at least in the de_DE dictionary.\n                  // I think the author mistakenly supplied lower-case rule codes instead\n                  // of upper-case.\n              }\n              */\n            }\n          }\n        }\n      }\n      return newWords;\n    },\n    /**\n     * Checks whether a word or a capitalization variant exists in the current dictionary.\n     * The word is trimmed and several variations of capitalizations are checked.\n     * If you want to check a word without any changes made to it, call checkExact()\n     *\n     * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n     *\n     * @param {string} aWord The word to check.\n     * @returns {boolean}\n     */\n    check: function (aWord) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n      if (!aWord) {\n        return false;\n      }\n      // Remove leading and trailing whitespace\n      var trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n      if (this.checkExact(trimmedWord)) {\n        return true;\n      }\n      // The exact word is not in the dictionary.\n      if (trimmedWord.toUpperCase() === trimmedWord) {\n        // The word was supplied in all uppercase.\n        // Check for a capitalized form of the word.\n        var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n        if (this.hasFlag(capitalizedWord, \"KEEPCASE\")) {\n          // Capitalization variants are not allowed for this word.\n          return false;\n        }\n        if (this.checkExact(capitalizedWord)) {\n          // The all-caps word is a capitalized word spelled correctly.\n          return true;\n        }\n        if (this.checkExact(trimmedWord.toLowerCase())) {\n          // The all-caps is a lowercase word spelled correctly.\n          return true;\n        }\n      }\n      var uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);\n      if (uncapitalizedWord !== trimmedWord) {\n        if (this.hasFlag(uncapitalizedWord, \"KEEPCASE\")) {\n          // Capitalization variants are not allowed for this word.\n          return false;\n        }\n        // Check for an uncapitalized form\n        if (this.checkExact(uncapitalizedWord)) {\n          // The word is spelled correctly but with the first letter capitalized.\n          return true;\n        }\n      }\n      return false;\n    },\n    /**\n     * Checks whether a word exists in the current dictionary.\n     *\n     * @param {string} word The word to check.\n     * @returns {boolean}\n     */\n    checkExact: function (word) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n      var ruleCodes = this.dictionaryTable[word];\n      var i, _len;\n      if (typeof ruleCodes === 'undefined') {\n        // Check if this might be a compound word.\n        if (\"COMPOUNDMIN\" in this.flags && word.length >= this.flags.COMPOUNDMIN) {\n          for (i = 0, _len = this.compoundRules.length; i < _len; i++) {\n            if (word.match(this.compoundRules[i])) {\n              return true;\n            }\n          }\n        }\n      } else if (ruleCodes === null) {\n        // a null (but not undefined) value for an entry in the dictionary table\n        // means that the word is in the dictionary but has no flags.\n        return true;\n      } else if (typeof ruleCodes === 'object') {\n        // this.dictionary['hasOwnProperty'] will be a function.\n        for (i = 0, _len = ruleCodes.length; i < _len; i++) {\n          if (!this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCodes[i])) {\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n    /**\n     * Looks up whether a given word is flagged with a given flag.\n     *\n     * @param {string} word The word in question.\n     * @param {string} flag The flag in question.\n     * @return {boolean}\n     */\n    hasFlag: function (word, flag, wordFlags) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n      if (flag in this.flags) {\n        if (typeof wordFlags === 'undefined') {\n          wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);\n        }\n        if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {\n          return true;\n        }\n      }\n      return false;\n    },\n    /**\n     * Returns a list of suggestions for a misspelled word.\n     *\n     * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n     * This suggestor is primitive, but it works.\n     *\n     * @param {string} word The misspelling.\n     * @param {number} [limit=5] The maximum number of suggestions to return.\n     * @returns {string[]} The array of suggestions.\n     */\n    alphabet: \"\",\n    suggest: function (word, limit) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n      limit = limit || 5;\n      if (this.memoized.hasOwnProperty(word)) {\n        var memoizedLimit = this.memoized[word]['limit'];\n        // Only return the cached list if it's big enough or if there weren't enough suggestions\n        // to fill a smaller limit.\n        if (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\n          return this.memoized[word]['suggestions'].slice(0, limit);\n        }\n      }\n      if (this.check(word)) return [];\n      // Check the replacement table.\n      for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {\n        var replacementEntry = this.replacementTable[i];\n        if (word.indexOf(replacementEntry[0]) !== -1) {\n          var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n          if (this.check(correctedWord)) {\n            return [correctedWord];\n          }\n        }\n      }\n      if (!this.alphabet) {\n        // Use the English alphabet as the default. Problematic, but backwards-compatible.\n        this.alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n        // Any characters defined in the affix file as substitutions can go in the alphabet too.\n        // Note that dictionaries do not include the entire alphabet in the TRY flag when it's there.\n        // For example, Q is not in the default English TRY list; that's why having the default\n        // alphabet above is useful.\n        if ('TRY' in this.flags) {\n          this.alphabet += this.flags['TRY'];\n        }\n        // Plus any additional characters specifically defined as being allowed in words.\n        if ('WORDCHARS' in this.flags) {\n          this.alphabet += this.flags['WORDCHARS'];\n        }\n        // Remove any duplicates.\n        var alphaArray = this.alphabet.split(\"\");\n        alphaArray.sort();\n        var alphaHash = {};\n        for (var i = 0; i < alphaArray.length; i++) {\n          alphaHash[alphaArray[i]] = true;\n        }\n        this.alphabet = '';\n        for (var i in alphaHash) {\n          this.alphabet += i;\n        }\n      }\n      var self = this;\n      /**\n       * Returns a hash keyed by all of the strings that can be made by making a single edit to the word (or words in) `words`\n       * The value of each entry is the number of unique ways that the resulting word can be made.\n       *\n       * @arg HashMap words A hash keyed by words (all with the value `true` to make lookups very quick).\n       * @arg boolean known_only Whether this function should ignore strings that are not in the dictionary.\n       */\n      function edits1(words, known_only) {\n        var rv = {};\n        var i, j, _iilen, _len, _jlen, _edit;\n        var alphabetLength = self.alphabet.length;\n        for (var word_1 in words) {\n          for (i = 0, _len = word_1.length + 1; i < _len; i++) {\n            var s = [word_1.substring(0, i), word_1.substring(i)];\n            // Remove a letter.\n            if (s[1]) {\n              _edit = s[0] + s[1].substring(1);\n              if (!known_only || self.check(_edit)) {\n                if (!(_edit in rv)) {\n                  rv[_edit] = 1;\n                } else {\n                  rv[_edit] += 1;\n                }\n              }\n            }\n            // Transpose letters\n            // Eliminate transpositions of identical letters\n            if (s[1].length > 1 && s[1][1] !== s[1][0]) {\n              _edit = s[0] + s[1][1] + s[1][0] + s[1].substring(2);\n              if (!known_only || self.check(_edit)) {\n                if (!(_edit in rv)) {\n                  rv[_edit] = 1;\n                } else {\n                  rv[_edit] += 1;\n                }\n              }\n            }\n            if (s[1]) {\n              // Replace a letter with another letter.\n              var lettercase = s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1) ? 'uppercase' : 'lowercase';\n              for (j = 0; j < alphabetLength; j++) {\n                var replacementLetter = self.alphabet[j];\n                // Set the case of the replacement letter to the same as the letter being replaced.\n                if ('uppercase' === lettercase) {\n                  replacementLetter = replacementLetter.toUpperCase();\n                }\n                // Eliminate replacement of a letter by itself\n                if (replacementLetter != s[1].substring(0, 1)) {\n                  _edit = s[0] + replacementLetter + s[1].substring(1);\n                  if (!known_only || self.check(_edit)) {\n                    if (!(_edit in rv)) {\n                      rv[_edit] = 1;\n                    } else {\n                      rv[_edit] += 1;\n                    }\n                  }\n                }\n              }\n            }\n            if (s[1]) {\n              // Add a letter between each letter.\n              for (j = 0; j < alphabetLength; j++) {\n                // If the letters on each side are capitalized, capitalize the replacement.\n                var lettercase = s[0].substring(-1).toUpperCase() === s[0].substring(-1) && s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1) ? 'uppercase' : 'lowercase';\n                var replacementLetter = self.alphabet[j];\n                if ('uppercase' === lettercase) {\n                  replacementLetter = replacementLetter.toUpperCase();\n                }\n                _edit = s[0] + replacementLetter + s[1];\n                if (!known_only || self.check(_edit)) {\n                  if (!(_edit in rv)) {\n                    rv[_edit] = 1;\n                  } else {\n                    rv[_edit] += 1;\n                  }\n                }\n              }\n            }\n          }\n        }\n        return rv;\n      }\n      function correct(word) {\n        var _a;\n        // Get the edit-distance-1 and edit-distance-2 forms of this word.\n        var ed1 = edits1((_a = {}, _a[word] = true, _a));\n        var ed2 = edits1(ed1, true);\n        // Sort the edits based on how many different ways they were created.\n        var weighted_corrections = ed2;\n        for (var ed1word in ed1) {\n          if (!self.check(ed1word)) {\n            continue;\n          }\n          if (ed1word in weighted_corrections) {\n            weighted_corrections[ed1word] += ed1[ed1word];\n          } else {\n            weighted_corrections[ed1word] = ed1[ed1word];\n          }\n        }\n        var i, _len;\n        var sorted_corrections = [];\n        for (i in weighted_corrections) {\n          if (weighted_corrections.hasOwnProperty(i)) {\n            sorted_corrections.push([i, weighted_corrections[i]]);\n          }\n        }\n        function sorter(a, b) {\n          var a_val = a[1];\n          var b_val = b[1];\n          if (a_val < b_val) {\n            return -1;\n          } else if (a_val > b_val) {\n            return 1;\n          }\n          // @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.\n          return b[0].localeCompare(a[0]);\n        }\n        sorted_corrections.sort(sorter).reverse();\n        var rv = [];\n        var capitalization_scheme = \"lowercase\";\n        if (word.toUpperCase() === word) {\n          capitalization_scheme = \"uppercase\";\n        } else if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {\n          capitalization_scheme = \"capitalized\";\n        }\n        var working_limit = limit;\n        for (i = 0; i < Math.min(working_limit, sorted_corrections.length); i++) {\n          if (\"uppercase\" === capitalization_scheme) {\n            sorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();\n          } else if (\"capitalized\" === capitalization_scheme) {\n            sorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);\n          }\n          if (!self.hasFlag(sorted_corrections[i][0], \"NOSUGGEST\") && rv.indexOf(sorted_corrections[i][0]) === -1) {\n            rv.push(sorted_corrections[i][0]);\n          } else {\n            // If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.\n            working_limit++;\n          }\n        }\n        return rv;\n      }\n      this.memoized[word] = {\n        'suggestions': correct(word),\n        'limit': limit\n      };\n      return this.memoized[word]['suggestions'];\n    }\n  };\n})();\n// Support for use as a node.js module.\nif (typeof module !== 'undefined') {\n  module.exports = Typo;\n}","map":{"version":3,"names":["Typo","dictionary","affData","wordsData","settings","rules","dictionaryTable","compoundRules","compoundRuleCodes","replacementTable","flags","memoized","loaded","self","path","i","j","_len","_jlen","setup","window","chrome","browser","runtime","dictionaryPath","readDataFile","getURL","setAffData","setWordsData","__dirname","url","setFunc","response","_readFile","asyncLoad","then","data","_parseAFF","length","rule","ONLYINCOMPOUND","_parseDIC","ruleText","expressionText","character","join","RegExp","loadedCallback","prototype","load","obj","hasOwnProperty","charset","async","_a","XMLHttpRequest","req_1","open","overrideMimeType","call","promise","Promise","resolve","reject","onload","status","responseText","statusText","onerror","send","require","fs","existsSync","readFileSync","console","log","e","line","subline","numEntries","lineParts","lines","split","_removeAffixComments","trim","definitionParts","ruleType","ruleCode","combineable","parseInt","entries","charactersToRemove","additionParts","charactersToAdd","continuationClasses","parseRuleCodes","regexToMatch","entry","add","match","remove","push","_removeDicComments","addWord","word","parts","ruleCodesArray","indexOf","NEEDAFFIX","code","newWords","_applyRule","ii","_iilen","newWord","k","combineCode","combineRule","type","otherNewWords","iii","_iiilen","otherNewWord","replace","textCodes","FLAG","substr","Array","from","continuationRule","concat","check","aWord","trimmedWord","checkExact","toUpperCase","capitalizedWord","substring","toLowerCase","hasFlag","uncapitalizedWord","ruleCodes","COMPOUNDMIN","flag","wordFlags","apply","alphabet","suggest","limit","memoizedLimit","slice","replacementEntry","correctedWord","alphaArray","sort","alphaHash","edits1","words","known_only","rv","_edit","alphabetLength","word_1","s","lettercase","replacementLetter","correct","ed1","ed2","weighted_corrections","ed1word","sorted_corrections","sorter","a","b","a_val","b_val","localeCompare","reverse","capitalization_scheme","working_limit","Math","min","module","exports"],"sources":["/Users/stevegrant/Downloads/rubric-app-styled-v8_2/node_modules/typo-js/typo.js"],"sourcesContent":["/* globals chrome: false */\n/* globals __dirname: false */\n/* globals require: false */\n/* globals Buffer: false */\n/* globals module: false */\n/**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style\n * dictionaries.\n */\nvar Typo;\n(function () {\n    \"use strict\";\n    /**\n     * Typo constructor.\n     *\n     * @param {string} [dictionary] The locale code of the dictionary being used. e.g.,\n     *                              \"en_US\". This is only used to auto-load dictionaries.\n     * @param {string} [affData]    The data from the dictionary's .aff file. If omitted\n     *                              and Typo.js is being used in a Chrome extension, the .aff\n     *                              file will be loaded automatically from\n     *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff\n     *                              In other environments, it will be loaded from\n     *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff\n     * @param {string} [wordsData]  The data from the dictionary's .dic file. If omitted\n     *                              and Typo.js is being used in a Chrome extension, the .dic\n     *                              file will be loaded automatically from\n     *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic\n     *                              In other environments, it will be loaded from\n     *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic\n     * @param {Object} [settings]   Constructor settings. Available properties are:\n     *                              {string} [dictionaryPath]: path to load dictionary from in non-chrome\n     *                              environment.\n     *                              {Object} [flags]: flag information.\n     *                              {boolean} [asyncLoad]: If true, affData and wordsData will be loaded\n     *                              asynchronously.\n     *                              {Function} [loadedCallback]: Called when both affData and wordsData\n     *                              have been loaded. Only used if asyncLoad is set to true. The parameter\n     *                              is the instantiated Typo object.\n     *\n     * @returns {Typo} A Typo object.\n     */\n    Typo = function (dictionary, affData, wordsData, settings) {\n        settings = settings || {};\n        this.dictionary = null;\n        this.rules = {};\n        this.dictionaryTable = {};\n        this.compoundRules = [];\n        this.compoundRuleCodes = {};\n        this.replacementTable = [];\n        this.flags = settings.flags || {};\n        this.memoized = {};\n        this.loaded = false;\n        var self = this;\n        var path;\n        // Loop-control variables.\n        var i, j, _len, _jlen;\n        if (dictionary) {\n            self.dictionary = dictionary;\n            // If the data is preloaded, just setup the Typo object.\n            if (affData && wordsData) {\n                setup();\n            }\n            // Loading data for Chrome extentions.\n            else if (typeof window !== 'undefined' && (window.chrome || window.browser)) {\n                var runtime = window.chrome && window.chrome.runtime ? window.chrome.runtime : browser.runtime;\n                if (settings.dictionaryPath) {\n                    path = settings.dictionaryPath;\n                }\n                else {\n                    path = \"typo/dictionaries\";\n                }\n                if (!affData)\n                    readDataFile(runtime.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\"), setAffData);\n                if (!wordsData)\n                    readDataFile(runtime.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\"), setWordsData);\n            }\n            // Loading data for Node.js or other environments.\n            else {\n                if (settings.dictionaryPath) {\n                    path = settings.dictionaryPath;\n                }\n                else if (typeof __dirname !== 'undefined') {\n                    path = __dirname + '/dictionaries';\n                }\n                else {\n                    path = './dictionaries';\n                }\n                if (!affData)\n                    readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\", setAffData);\n                if (!wordsData)\n                    readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\", setWordsData);\n            }\n        }\n        function readDataFile(url, setFunc) {\n            var response = self._readFile(url, null, settings === null || settings === void 0 ? void 0 : settings.asyncLoad);\n            if (settings === null || settings === void 0 ? void 0 : settings.asyncLoad) {\n                response.then(function (data) {\n                    setFunc(data);\n                });\n            }\n            else {\n                setFunc(response);\n            }\n        }\n        function setAffData(data) {\n            affData = data;\n            if (wordsData) {\n                setup();\n            }\n        }\n        function setWordsData(data) {\n            wordsData = data;\n            if (affData) {\n                setup();\n            }\n        }\n        function setup() {\n            self.rules = self._parseAFF(affData);\n            // Save the rule codes that are used in compound rules.\n            self.compoundRuleCodes = {};\n            for (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n                var rule = self.compoundRules[i];\n                for (j = 0, _jlen = rule.length; j < _jlen; j++) {\n                    self.compoundRuleCodes[rule[j]] = [];\n                }\n            }\n            // If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n            // will do the work of saving the list of words that are compound-only.\n            if (\"ONLYINCOMPOUND\" in self.flags) {\n                self.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];\n            }\n            self.dictionaryTable = self._parseDIC(wordsData);\n            // Get rid of any codes from the compound rule codes that are never used\n            // (or that were special regex characters).  Not especially necessary...\n            for (i in self.compoundRuleCodes) {\n                if (self.compoundRuleCodes[i].length === 0) {\n                    delete self.compoundRuleCodes[i];\n                }\n            }\n            // Build the full regular expressions for each compound rule.\n            // I have a feeling (but no confirmation yet) that this method of\n            // testing for compound words is probably slow.\n            for (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n                var ruleText = self.compoundRules[i];\n                var expressionText = \"\";\n                for (j = 0, _jlen = ruleText.length; j < _jlen; j++) {\n                    var character = ruleText[j];\n                    if (character in self.compoundRuleCodes) {\n                        expressionText += \"(\" + self.compoundRuleCodes[character].join(\"|\") + \")\";\n                    }\n                    else {\n                        expressionText += character;\n                    }\n                }\n                self.compoundRules[i] = new RegExp('^' + expressionText + '$', \"i\");\n            }\n            self.loaded = true;\n            if ((settings === null || settings === void 0 ? void 0 : settings.asyncLoad) && (settings === null || settings === void 0 ? void 0 : settings.loadedCallback)) {\n                settings.loadedCallback(self);\n            }\n        }\n        return this;\n    };\n    Typo.prototype = {\n        /**\n         * Loads a Typo instance from a hash of all of the Typo properties.\n         *\n         * @param {object} obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n         */\n        load: function (obj) {\n            for (var i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    this[i] = obj[i];\n                }\n            }\n            return this;\n        },\n        /**\n         * Read the contents of a file.\n         *\n         * @param {string} path The path (relative) to the file.\n         * @param {string} [charset=\"ISO8859-1\"] The expected charset of the file\n         * @param {boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n         *        files are read synchronously.\n         * @returns {string} The file data if async is false, otherwise a promise object. If running node.js, the data is\n         *          always returned.\n         */\n        _readFile: function (path, charset, async) {\n            var _a;\n            charset = charset || \"utf8\";\n            if (typeof XMLHttpRequest !== 'undefined') {\n                var req_1 = new XMLHttpRequest();\n                req_1.open(\"GET\", path, !!async);\n                (_a = req_1.overrideMimeType) === null || _a === void 0 ? void 0 : _a.call(req_1, \"text/plain; charset=\" + charset);\n                if (!!async) {\n                    var promise = new Promise(function (resolve, reject) {\n                        req_1.onload = function () {\n                            if (req_1.status === 200) {\n                                resolve(req_1.responseText);\n                            }\n                            else {\n                                reject(req_1.statusText);\n                            }\n                        };\n                        req_1.onerror = function () {\n                            reject(req_1.statusText);\n                        };\n                    });\n                    req_1.send(null);\n                    return promise;\n                }\n                else {\n                    req_1.send(null);\n                    return req_1.responseText;\n                }\n            }\n            else if (typeof require !== 'undefined') {\n                // Node.js\n                var fs = require(\"fs\");\n                try {\n                    if (fs.existsSync(path)) {\n                        return fs.readFileSync(path, charset);\n                    }\n                    else {\n                        console.log(\"Path \" + path + \" does not exist.\");\n                    }\n                }\n                catch (e) {\n                    console.log(e);\n                }\n                return '';\n            }\n            return '';\n        },\n        /**\n         * Parse the rules out from a .aff file.\n         *\n         * @param {string} data The contents of the affix file.\n         * @returns object The rules from the file.\n         */\n        _parseAFF: function (data) {\n            var rules = {};\n            var line, subline, numEntries, lineParts;\n            var i, j, _len, _jlen;\n            var lines = data.split(/\\r?\\n/);\n            for (i = 0, _len = lines.length; i < _len; i++) {\n                // Remove comment lines\n                line = this._removeAffixComments(lines[i]);\n                line = line.trim();\n                if (!line) {\n                    continue;\n                }\n                var definitionParts = line.split(/\\s+/);\n                var ruleType = definitionParts[0];\n                if (ruleType === \"PFX\" || ruleType === \"SFX\") {\n                    var ruleCode = definitionParts[1];\n                    var combineable = definitionParts[2];\n                    numEntries = parseInt(definitionParts[3], 10);\n                    var entries = [];\n                    for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n                        subline = lines[j];\n                        lineParts = subline.split(/\\s+/);\n                        var charactersToRemove = lineParts[2];\n                        var additionParts = lineParts[3].split(\"/\");\n                        var charactersToAdd = additionParts[0];\n                        if (charactersToAdd === \"0\")\n                            charactersToAdd = \"\";\n                        var continuationClasses = this.parseRuleCodes(additionParts[1]);\n                        var regexToMatch = lineParts[4];\n                        var entry = {\n                            add: charactersToAdd\n                        };\n                        if (continuationClasses.length > 0)\n                            entry.continuationClasses = continuationClasses;\n                        if (regexToMatch !== \".\") {\n                            if (ruleType === \"SFX\") {\n                                entry.match = new RegExp(regexToMatch + \"$\");\n                            }\n                            else {\n                                entry.match = new RegExp(\"^\" + regexToMatch);\n                            }\n                        }\n                        if (charactersToRemove != \"0\") {\n                            if (ruleType === \"SFX\") {\n                                entry.remove = new RegExp(charactersToRemove + \"$\");\n                            }\n                            else {\n                                entry.remove = charactersToRemove;\n                            }\n                        }\n                        entries.push(entry);\n                    }\n                    rules[ruleCode] = { \"type\": ruleType, \"combineable\": (combineable === \"Y\"), \"entries\": entries };\n                    i += numEntries;\n                }\n                else if (ruleType === \"COMPOUNDRULE\") {\n                    numEntries = parseInt(definitionParts[1], 10);\n                    for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n                        line = lines[j];\n                        lineParts = line.split(/\\s+/);\n                        this.compoundRules.push(lineParts[1]);\n                    }\n                    i += numEntries;\n                }\n                else if (ruleType === \"REP\") {\n                    lineParts = line.split(/\\s+/);\n                    if (lineParts.length === 3) {\n                        this.replacementTable.push([lineParts[1], lineParts[2]]);\n                    }\n                }\n                else {\n                    // ONLYINCOMPOUND\n                    // COMPOUNDMIN\n                    // FLAG\n                    // KEEPCASE\n                    // NEEDAFFIX\n                    this.flags[ruleType] = definitionParts[1];\n                }\n            }\n            return rules;\n        },\n        /**\n         * Removes comments.\n         *\n         * @param {string} data A line from an affix file.\n         * @return {string} The cleaned-up line.\n         */\n        _removeAffixComments: function (line) {\n            // This used to remove any string starting with '#' up to the end of the line,\n            // but some COMPOUNDRULE definitions include '#' as part of the rule.\n            // So, only remove lines that begin with a comment, optionally preceded by whitespace.\n            if (line.match(/^\\s*#/)) {\n                return '';\n            }\n            return line;\n        },\n        /**\n         * Parses the words out from the .dic file.\n         *\n         * @param {string} data The data from the dictionary file.\n         * @returns HashMap The lookup table containing all of the words and\n         *                 word forms from the dictionary.\n         */\n        _parseDIC: function (data) {\n            data = this._removeDicComments(data);\n            var lines = data.split(/\\r?\\n/);\n            var dictionaryTable = {};\n            function addWord(word, rules) {\n                // Some dictionaries will list the same word multiple times with different rule sets.\n                if (!dictionaryTable.hasOwnProperty(word)) {\n                    dictionaryTable[word] = null;\n                }\n                if (rules.length > 0) {\n                    if (dictionaryTable[word] === null) {\n                        dictionaryTable[word] = [];\n                    }\n                    dictionaryTable[word].push(rules);\n                }\n            }\n            // The first line is the number of words in the dictionary.\n            for (var i = 1, _len = lines.length; i < _len; i++) {\n                var line = lines[i];\n                if (!line) {\n                    // Ignore empty lines.\n                    continue;\n                }\n                var parts = line.split(\"/\", 2);\n                var word = parts[0];\n                // Now for each affix rule, generate that form of the word.\n                if (parts.length > 1) {\n                    var ruleCodesArray = this.parseRuleCodes(parts[1]);\n                    // Save the ruleCodes for compound word situations.\n                    if (!(\"NEEDAFFIX\" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) === -1) {\n                        addWord(word, ruleCodesArray);\n                    }\n                    for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {\n                        var code = ruleCodesArray[j];\n                        var rule = this.rules[code];\n                        if (rule) {\n                            var newWords = this._applyRule(word, rule);\n                            for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {\n                                var newWord = newWords[ii];\n                                addWord(newWord, []);\n                                if (rule.combineable) {\n                                    for (var k = j + 1; k < _jlen; k++) {\n                                        var combineCode = ruleCodesArray[k];\n                                        var combineRule = this.rules[combineCode];\n                                        if (combineRule) {\n                                            if (combineRule.combineable && (rule.type != combineRule.type)) {\n                                                var otherNewWords = this._applyRule(newWord, combineRule);\n                                                for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {\n                                                    var otherNewWord = otherNewWords[iii];\n                                                    addWord(otherNewWord, []);\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if (code in this.compoundRuleCodes) {\n                            this.compoundRuleCodes[code].push(word);\n                        }\n                    }\n                }\n                else {\n                    addWord(word.trim(), []);\n                }\n            }\n            return dictionaryTable;\n        },\n        /**\n         * Removes comment lines and then cleans up blank lines and trailing whitespace.\n         *\n         * @param {string} data The data from a .dic file.\n         * @return {string} The cleaned-up data.\n         */\n        _removeDicComments: function (data) {\n            // I can't find any official documentation on it, but at least the de_DE\n            // dictionary uses tab-indented lines as comments.\n            // Remove comments\n            data = data.replace(/^\\t.*$/mg, \"\");\n            return data;\n        },\n        parseRuleCodes: function (textCodes) {\n            if (!textCodes) {\n                return [];\n            }\n            else if (!(\"FLAG\" in this.flags)) {\n                // The flag symbols are single characters\n                return textCodes.split(\"\");\n            }\n            else if (this.flags.FLAG === \"long\") {\n                // The flag symbols are two characters long.\n                var flags = [];\n                for (var i = 0, _len = textCodes.length; i < _len; i += 2) {\n                    flags.push(textCodes.substr(i, 2));\n                }\n                return flags;\n            }\n            else if (this.flags.FLAG === \"num\") {\n                // The flag symbols are a CSV list of numbers.\n                return textCodes.split(\",\");\n            }\n            else if (this.flags.FLAG === \"UTF-8\") {\n                // The flags are single UTF-8 characters.\n                // @see https://github.com/cfinke/Typo.js/issues/57\n                return Array.from(textCodes);\n            }\n            else {\n                // It's possible that this fallback case will not work for all FLAG values,\n                // but I think it's more likely to work than not returning anything at all.\n                return textCodes.split(\"\");\n            }\n        },\n        /**\n         * Applies an affix rule to a word.\n         *\n         * @param {string} word The base word.\n         * @param {Object} rule The affix rule.\n         * @returns {string[]} The new words generated by the rule.\n         */\n        _applyRule: function (word, rule) {\n            var entries = rule.entries;\n            var newWords = [];\n            for (var i = 0, _len = entries.length; i < _len; i++) {\n                var entry = entries[i];\n                if (!entry.match || word.match(entry.match)) {\n                    var newWord = word;\n                    if (entry.remove) {\n                        newWord = newWord.replace(entry.remove, \"\");\n                    }\n                    if (rule.type === \"SFX\") {\n                        newWord = newWord + entry.add;\n                    }\n                    else {\n                        newWord = entry.add + newWord;\n                    }\n                    newWords.push(newWord);\n                    if (\"continuationClasses\" in entry) {\n                        for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {\n                            var continuationRule = this.rules[entry.continuationClasses[j]];\n                            if (continuationRule) {\n                                newWords = newWords.concat(this._applyRule(newWord, continuationRule));\n                            }\n                            /*\n                            else {\n                                // This shouldn't happen, but it does, at least in the de_DE dictionary.\n                                // I think the author mistakenly supplied lower-case rule codes instead\n                                // of upper-case.\n                            }\n                            */\n                        }\n                    }\n                }\n            }\n            return newWords;\n        },\n        /**\n         * Checks whether a word or a capitalization variant exists in the current dictionary.\n         * The word is trimmed and several variations of capitalizations are checked.\n         * If you want to check a word without any changes made to it, call checkExact()\n         *\n         * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n         *\n         * @param {string} aWord The word to check.\n         * @returns {boolean}\n         */\n        check: function (aWord) {\n            if (!this.loaded) {\n                throw \"Dictionary not loaded.\";\n            }\n            if (!aWord) {\n                return false;\n            }\n            // Remove leading and trailing whitespace\n            var trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n            if (this.checkExact(trimmedWord)) {\n                return true;\n            }\n            // The exact word is not in the dictionary.\n            if (trimmedWord.toUpperCase() === trimmedWord) {\n                // The word was supplied in all uppercase.\n                // Check for a capitalized form of the word.\n                var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n                if (this.hasFlag(capitalizedWord, \"KEEPCASE\")) {\n                    // Capitalization variants are not allowed for this word.\n                    return false;\n                }\n                if (this.checkExact(capitalizedWord)) {\n                    // The all-caps word is a capitalized word spelled correctly.\n                    return true;\n                }\n                if (this.checkExact(trimmedWord.toLowerCase())) {\n                    // The all-caps is a lowercase word spelled correctly.\n                    return true;\n                }\n            }\n            var uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);\n            if (uncapitalizedWord !== trimmedWord) {\n                if (this.hasFlag(uncapitalizedWord, \"KEEPCASE\")) {\n                    // Capitalization variants are not allowed for this word.\n                    return false;\n                }\n                // Check for an uncapitalized form\n                if (this.checkExact(uncapitalizedWord)) {\n                    // The word is spelled correctly but with the first letter capitalized.\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n         * Checks whether a word exists in the current dictionary.\n         *\n         * @param {string} word The word to check.\n         * @returns {boolean}\n         */\n        checkExact: function (word) {\n            if (!this.loaded) {\n                throw \"Dictionary not loaded.\";\n            }\n            var ruleCodes = this.dictionaryTable[word];\n            var i, _len;\n            if (typeof ruleCodes === 'undefined') {\n                // Check if this might be a compound word.\n                if (\"COMPOUNDMIN\" in this.flags && word.length >= this.flags.COMPOUNDMIN) {\n                    for (i = 0, _len = this.compoundRules.length; i < _len; i++) {\n                        if (word.match(this.compoundRules[i])) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            else if (ruleCodes === null) {\n                // a null (but not undefined) value for an entry in the dictionary table\n                // means that the word is in the dictionary but has no flags.\n                return true;\n            }\n            else if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.\n                for (i = 0, _len = ruleCodes.length; i < _len; i++) {\n                    if (!this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCodes[i])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        /**\n         * Looks up whether a given word is flagged with a given flag.\n         *\n         * @param {string} word The word in question.\n         * @param {string} flag The flag in question.\n         * @return {boolean}\n         */\n        hasFlag: function (word, flag, wordFlags) {\n            if (!this.loaded) {\n                throw \"Dictionary not loaded.\";\n            }\n            if (flag in this.flags) {\n                if (typeof wordFlags === 'undefined') {\n                    wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);\n                }\n                if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n         * Returns a list of suggestions for a misspelled word.\n         *\n         * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n         * This suggestor is primitive, but it works.\n         *\n         * @param {string} word The misspelling.\n         * @param {number} [limit=5] The maximum number of suggestions to return.\n         * @returns {string[]} The array of suggestions.\n         */\n        alphabet: \"\",\n        suggest: function (word, limit) {\n            if (!this.loaded) {\n                throw \"Dictionary not loaded.\";\n            }\n            limit = limit || 5;\n            if (this.memoized.hasOwnProperty(word)) {\n                var memoizedLimit = this.memoized[word]['limit'];\n                // Only return the cached list if it's big enough or if there weren't enough suggestions\n                // to fill a smaller limit.\n                if (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\n                    return this.memoized[word]['suggestions'].slice(0, limit);\n                }\n            }\n            if (this.check(word))\n                return [];\n            // Check the replacement table.\n            for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {\n                var replacementEntry = this.replacementTable[i];\n                if (word.indexOf(replacementEntry[0]) !== -1) {\n                    var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n                    if (this.check(correctedWord)) {\n                        return [correctedWord];\n                    }\n                }\n            }\n            if (!this.alphabet) {\n                // Use the English alphabet as the default. Problematic, but backwards-compatible.\n                this.alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n                // Any characters defined in the affix file as substitutions can go in the alphabet too.\n                // Note that dictionaries do not include the entire alphabet in the TRY flag when it's there.\n                // For example, Q is not in the default English TRY list; that's why having the default\n                // alphabet above is useful.\n                if ('TRY' in this.flags) {\n                    this.alphabet += this.flags['TRY'];\n                }\n                // Plus any additional characters specifically defined as being allowed in words.\n                if ('WORDCHARS' in this.flags) {\n                    this.alphabet += this.flags['WORDCHARS'];\n                }\n                // Remove any duplicates.\n                var alphaArray = this.alphabet.split(\"\");\n                alphaArray.sort();\n                var alphaHash = {};\n                for (var i = 0; i < alphaArray.length; i++) {\n                    alphaHash[alphaArray[i]] = true;\n                }\n                this.alphabet = '';\n                for (var i in alphaHash) {\n                    this.alphabet += i;\n                }\n            }\n            var self = this;\n            /**\n             * Returns a hash keyed by all of the strings that can be made by making a single edit to the word (or words in) `words`\n             * The value of each entry is the number of unique ways that the resulting word can be made.\n             *\n             * @arg HashMap words A hash keyed by words (all with the value `true` to make lookups very quick).\n             * @arg boolean known_only Whether this function should ignore strings that are not in the dictionary.\n             */\n            function edits1(words, known_only) {\n                var rv = {};\n                var i, j, _iilen, _len, _jlen, _edit;\n                var alphabetLength = self.alphabet.length;\n                for (var word_1 in words) {\n                    for (i = 0, _len = word_1.length + 1; i < _len; i++) {\n                        var s = [word_1.substring(0, i), word_1.substring(i)];\n                        // Remove a letter.\n                        if (s[1]) {\n                            _edit = s[0] + s[1].substring(1);\n                            if (!known_only || self.check(_edit)) {\n                                if (!(_edit in rv)) {\n                                    rv[_edit] = 1;\n                                }\n                                else {\n                                    rv[_edit] += 1;\n                                }\n                            }\n                        }\n                        // Transpose letters\n                        // Eliminate transpositions of identical letters\n                        if (s[1].length > 1 && s[1][1] !== s[1][0]) {\n                            _edit = s[0] + s[1][1] + s[1][0] + s[1].substring(2);\n                            if (!known_only || self.check(_edit)) {\n                                if (!(_edit in rv)) {\n                                    rv[_edit] = 1;\n                                }\n                                else {\n                                    rv[_edit] += 1;\n                                }\n                            }\n                        }\n                        if (s[1]) {\n                            // Replace a letter with another letter.\n                            var lettercase = (s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1)) ? 'uppercase' : 'lowercase';\n                            for (j = 0; j < alphabetLength; j++) {\n                                var replacementLetter = self.alphabet[j];\n                                // Set the case of the replacement letter to the same as the letter being replaced.\n                                if ('uppercase' === lettercase) {\n                                    replacementLetter = replacementLetter.toUpperCase();\n                                }\n                                // Eliminate replacement of a letter by itself\n                                if (replacementLetter != s[1].substring(0, 1)) {\n                                    _edit = s[0] + replacementLetter + s[1].substring(1);\n                                    if (!known_only || self.check(_edit)) {\n                                        if (!(_edit in rv)) {\n                                            rv[_edit] = 1;\n                                        }\n                                        else {\n                                            rv[_edit] += 1;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if (s[1]) {\n                            // Add a letter between each letter.\n                            for (j = 0; j < alphabetLength; j++) {\n                                // If the letters on each side are capitalized, capitalize the replacement.\n                                var lettercase = (s[0].substring(-1).toUpperCase() === s[0].substring(-1) && s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1)) ? 'uppercase' : 'lowercase';\n                                var replacementLetter = self.alphabet[j];\n                                if ('uppercase' === lettercase) {\n                                    replacementLetter = replacementLetter.toUpperCase();\n                                }\n                                _edit = s[0] + replacementLetter + s[1];\n                                if (!known_only || self.check(_edit)) {\n                                    if (!(_edit in rv)) {\n                                        rv[_edit] = 1;\n                                    }\n                                    else {\n                                        rv[_edit] += 1;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                return rv;\n            }\n            function correct(word) {\n                var _a;\n                // Get the edit-distance-1 and edit-distance-2 forms of this word.\n                var ed1 = edits1((_a = {}, _a[word] = true, _a));\n                var ed2 = edits1(ed1, true);\n                // Sort the edits based on how many different ways they were created.\n                var weighted_corrections = ed2;\n                for (var ed1word in ed1) {\n                    if (!self.check(ed1word)) {\n                        continue;\n                    }\n                    if (ed1word in weighted_corrections) {\n                        weighted_corrections[ed1word] += ed1[ed1word];\n                    }\n                    else {\n                        weighted_corrections[ed1word] = ed1[ed1word];\n                    }\n                }\n                var i, _len;\n                var sorted_corrections = [];\n                for (i in weighted_corrections) {\n                    if (weighted_corrections.hasOwnProperty(i)) {\n                        sorted_corrections.push([i, weighted_corrections[i]]);\n                    }\n                }\n                function sorter(a, b) {\n                    var a_val = a[1];\n                    var b_val = b[1];\n                    if (a_val < b_val) {\n                        return -1;\n                    }\n                    else if (a_val > b_val) {\n                        return 1;\n                    }\n                    // @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.\n                    return b[0].localeCompare(a[0]);\n                }\n                sorted_corrections.sort(sorter).reverse();\n                var rv = [];\n                var capitalization_scheme = \"lowercase\";\n                if (word.toUpperCase() === word) {\n                    capitalization_scheme = \"uppercase\";\n                }\n                else if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {\n                    capitalization_scheme = \"capitalized\";\n                }\n                var working_limit = limit;\n                for (i = 0; i < Math.min(working_limit, sorted_corrections.length); i++) {\n                    if (\"uppercase\" === capitalization_scheme) {\n                        sorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();\n                    }\n                    else if (\"capitalized\" === capitalization_scheme) {\n                        sorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);\n                    }\n                    if (!self.hasFlag(sorted_corrections[i][0], \"NOSUGGEST\") && rv.indexOf(sorted_corrections[i][0]) === -1) {\n                        rv.push(sorted_corrections[i][0]);\n                    }\n                    else {\n                        // If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.\n                        working_limit++;\n                    }\n                }\n                return rv;\n            }\n            this.memoized[word] = {\n                'suggestions': correct(word),\n                'limit': limit\n            };\n            return this.memoized[word]['suggestions'];\n        }\n    };\n})();\n// Support for use as a node.js module.\nif (typeof module !== 'undefined') {\n    module.exports = Typo;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}